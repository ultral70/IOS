//Ver los tipos m√°s importantes en Swift y en algunos m√©todos y formas de trabajar

//Enteros
let numero : Int //declaraci√≥n
let numerosDeLaMano = 5 //Creaci√≥n con inferencia de tipos, decidiendo en tiempo de ejecuci√≥n el tipo de variable, o constante

//Para n√∫meros grandes, se puede poner _ para separar millares, siendo as√≠ m√°s agradable a la vista
let numeroDeEstrellas = 1_000_000_000_000

print(type(of:numero))
print(type(of:numerosDeLaMano))
print(type(of:numeroDeEstrellas))

//Otros sistemas num√©ricos
let nBinario = 0b101 // 0b para binario
let nOctal = 0o21 // 0o para octal
let nHexa = 0xAAFF // 0x para hexadecimal

print(nBinario)
print(nOctal)
print(nHexa)

//Double
let decimalUno : Double
//Son n√∫meros en coma flotante, es decir, que aumentan decimales, hasta 64 bits; con precisi√≥n de 15 d√≠gitos
decimalUno = 12.12345
//A√±adiendo una e y un n√∫mero despu√©s, logramos que el n√∫mero se multiplique por un exponente (10 elevado a 1 etc.)
var decimalConExponente = 1.212345e8
print(decimalUno)
print(decimalConExponente)

//Float
//Son n√∫meros en coma flotante hasta 32 bits, con precisi√≥n de 5 d√≠gitos
//Mejor utilizar Double
var numeroFloat : Float = 12.12345

//Booleanas
var verdadero : Bool = true // Declarando
var falso = false //Inferencia de tipos

//Caracteres
let caracter : Character = "f"

//Strings
//Representan cadenas de Caracteres
var cadena = "Esto es un Strin muy bonito"
var cadena2 : String = "Esto ser√≠a otra cadena"

//Dos maneras de crear un objeto String
cadena = "Homer"
cadena2 = String("Homer")
//Ambas maneras son equivalentes

//Comparaci√≥n
if cadena == cadena2 {

print("Las cadenas son iguales")

}

//String vac√≠o
if cadena.isEmpty {

print("Cadena vac√≠a")

} else {

  print("La cadena no est√° vac√≠a")

}

//Mutabilidad
//Un objeto es inmutable cuando no podemos cambiar su estado durante su ciclo de vida
//El estado de un objeto es el valor de sus atributos
//En swift hacemos un String mutable con "var"
var stringMutable = "Caballo"
stringMutable += " y Caballa" //Concatena

//Hacemos inmutable con let
let stringInmutable = "Vaca"
//No podemos hacerlo
//stringInmutable += " Toro"

//Recorrer un string
cadena = "Estoy feliz üöÇ"

//Podemos usar un for-each
for otroCaracter in cadena {

  print(otroCaracter)

}

//Podemos crear un String a partir de un array de Caracteres
let caracteresDeGato : [Character] = ["C", "A", "T", "!"]
//Usamos el constructor Strin y le pasamos el array, en swift los objetos se crean sin "new"
let stringDeGato = String(caracteresDeGato)
print(stringDeGato)

//Concatenaci√≥n
let string1 = "Hola, "
let string2 = "¬øc√≥mo est√°s?"
var string3 = string1 + string2

//Tambi√©n con append
string3.append(" Yo bien üöÇ ")
print(string3)

//Tambi√©n podemos concatenar con "+="
string3 += " Me alegro mucho! üöÇ"
print(string3)

//Interpolaci√≥n
var numeroDoble : Double = 74.3456
string3.append("Mira que n√∫mero acabo de calcular: ")
//string3 += numeroDoble
//no podemos concatenar a un String otra cosa que no sea String
string3 += String(numeroDoble)
print(string3)
string3 += " y ahora pongo otra vez el n√∫mero \(numeroDoble)" //Interpolaci√≥n
print(string3)

//Caractere unicode
let sonrisa = "üöÇ"
let sonrisa2 = "\u{1F682}"
print(sonrisa)
print(sonrisa2)

//comparaciones con nil
var cadena3 = "Goku" //tipo normal
var cadena4 : String! = "Goku" //tipo optional
if(cadena3 == cadena4) {

  print("Son iguales")

}

//String multil√≠nea
//Caracter√≠stica de swift por la cual podemos crear de manera sencilla textos con varias l√≠neas
var html = "<html>"
html += "<head><title>Mi p√°gina web</title></head>"
html += "<body>"
//esto es un poco rollo... :(
//Podemos usar Strings multil√≠neas (""")
var htmlMultilinea = """
<html>
    <head>
        <title>Mi p√°gina web</title>
    </head>
    <body>
        <h1>P</h1>
    </body>
</html>
"""
print(htmlMultilinea)

//Contar caracteres de un String
print("El n√∫mero de caracteres de la palabra \(cadena3) es \(cadena3.count)")

//Tratamiento de caracteres con String
//STRING ES UN CONJUNTO DE CARACTERES CON ALGUNA PECURIALIDAD... :(

let saludo = "Guten tag!"
//Cada posici√≥n del String tiene un "Tipo √≠ndice" asociado, llamado "String.index" el cual corresponde con la posici√≥n de cada caracter del String
print(saludo)
//print(saludo[0]) // no podemos hacerlo :( :(

//Para manejar las posiciones de un String tenemos que jugar con una serie de funciones y propiedades
//startIndex -> propiedad que representa la primera letra de la cadena
//endIndex -> propiedad que representa LA SIGUIENTE POSICI√ìN a la √öLTIMA LETRA de la cadena

print(saludo.startIndex) //Me dice la posici√≥n 1
print(saludo[saludo.startIndex]) //G
//print(saludo[saludo.endIndex]) //Esto da error
//La clase String tiene un m√©todo que se llama index, que nos devuelve un caracter de la cadena, bajo algunas condiciones
//Ej, para sacar el √∫ltimo car√°cter
var indiceCreado = saludo.index(before: saludo.endIndex) //!
print(saludo[indiceCreado])

//podemos contar caracteres desde el principio
//por ejemplo 7 caracteres desde el principio
//La funci√≥n index est√° sobrecargada, en este caso primero le pasamos desde donde queremos empezar y, a continuaci√≥n, le damos cuantos caracteres queremos recorrer
indiceCreado = saludo.index(saludo.startIndex, offsetBy: 7)
print(saludo[indiceCreado]) //a

indiceCreado = saludo.index(saludo.endIndex, offsetBy: -4)
print(saludo[indiceCreado])

//Insertar caracteres en una posici√≥n concreta
var bienvenida = "welcome"
bienvenida.insert("!", at: bienvenida.endIndex)
print(bienvenida)

//Casting, cambiar de tipos
//En swift debemos de usar los constructores de clase para cambiar de tipo
let numeroEntero = 12 //El tipo ser√° Int, por inferencia
let numeroDoble2 = Double(numeroEntero)

print(type (of: numeroDoble2))

//Si hay riesgo de casteo, swift devuelve un Optional
cadena = "32"
let enteroConvertido = Int(cadena)! //Esto ser√≠a un optional, en caso de que no pueda convertirlo apuntar√≠a a nil
print(enteroConvertido ?? "valor no convertido") //Ponemos ! para desenvolver el optional